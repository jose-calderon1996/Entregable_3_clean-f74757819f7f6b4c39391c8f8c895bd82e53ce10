{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/jose/Desktop/Entregable_3_clean-f74757819f7f6b4c39391c8f8c895bd82e53ce10/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { WebPlugin } from '@capacitor/core';\nimport * as _jsQR from './jsqr.js';\nconst jsQR = _jsQR.default || _jsQR;\nexport class BarcodeScannerWeb extends WebPlugin {\n  multiScan(opts) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const scans = yield _this.readInternal(opts.maxScans);\n      if (scans.length > 0) {\n        return {\n          result: true,\n          codes: scans,\n          count: scans.length\n        };\n      } else {\n        return {\n          result: false,\n          count: 0,\n          codes: []\n        };\n      }\n    })();\n  }\n  scan() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const scans = yield _this2.readInternal();\n      if (scans.length > 0) {\n        return {\n          result: true,\n          code: scans[0]\n        };\n      } else {\n        return {\n          result: false\n        };\n      }\n    })();\n  }\n  readInternal(reads = 1) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const fInput = document.createElement('input');\n      fInput.type = 'file';\n      fInput.accept = 'image/*';\n      if (reads > 1) {\n        fInput.multiple = true;\n      }\n      fInput.style.display = 'none';\n      document.body.appendChild(fInput);\n      const promise = new Promise(resolve => {\n        fInput.addEventListener('change', /*#__PURE__*/_asyncToGenerator(function* () {\n          try {\n            if (fInput.files && fInput.files.length > 0) {\n              const scans = [];\n              const min = Math.min(fInput.files.length, reads);\n              for (let i = 0; i < min; i++) {\n                const img = fInput.files[i];\n                const imgData = yield _this3.blobToImageData(img);\n                const code = jsQR(imgData.data, imgData.width, imgData.height);\n                //console.log(code);\n                if (code && code.data) {\n                  scans.push(code.data);\n                } else {\n                  console.error('jsQR return null', code);\n                }\n              }\n              resolve(scans);\n            } else {\n              resolve([]);\n            }\n          } catch (error) {\n            console.error(error);\n          }\n          document.body.removeChild(fInput);\n        }));\n      });\n      fInput.click();\n      return promise;\n    })();\n  }\n  blobToImageData(blob, maxWidth = 1500, maxHeight = 1500) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = () => {\n          const image = new Image();\n          image.src = reader.result;\n          image.onload = () => {\n            const scale = Math.min(maxWidth / image.width, maxHeight / image.height, 1);\n            const canvas = document.createElement('canvas');\n            canvas.width = image.width * scale;\n            canvas.height = image.height * scale;\n            const ctx = canvas.getContext('2d');\n            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            // Libera la memoria de la imagen y del canvas\n            canvas.width = 0;\n            canvas.height = 0;\n            resolve(imageData);\n          };\n          image.onerror = e => reject(new Error(\"Error al cargar la imagen.\" + e));\n        };\n        reader.onerror = e => reject(new Error(\"Error al leer el blob.\" + e));\n      });\n    })();\n  }\n}","map":{"version":3,"names":["WebPlugin","_jsQR","jsQR","default","BarcodeScannerWeb","multiScan","opts","_this","_asyncToGenerator","scans","readInternal","maxScans","length","result","codes","count","scan","_this2","code","reads","_this3","fInput","document","createElement","type","accept","multiple","style","display","body","appendChild","promise","Promise","resolve","addEventListener","files","min","Math","i","img","imgData","blobToImageData","data","width","height","push","console","error","removeChild","click","blob","maxWidth","maxHeight","reject","reader","FileReader","readAsDataURL","onloadend","image","Image","src","onload","scale","canvas","ctx","getContext","drawImage","imageData","getImageData","onerror","e","Error"],"sources":["C:/Users/jose/Desktop/Entregable_3_clean-f74757819f7f6b4c39391c8f8c895bd82e53ce10/node_modules/capacitor-barcode-scanner/dist/esm/web.js"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\r\nimport * as _jsQR from './jsqr.js';\r\nconst jsQR = _jsQR.default || _jsQR;\r\nexport class BarcodeScannerWeb extends WebPlugin {\r\n    async multiScan(opts) {\r\n        const scans = await this.readInternal(opts.maxScans);\r\n        if (scans.length > 0) {\r\n            return { result: true, codes: scans, count: scans.length };\r\n        }\r\n        else {\r\n            return { result: false, count: 0, codes: [] };\r\n        }\r\n    }\r\n    async scan() {\r\n        const scans = await this.readInternal();\r\n        if (scans.length > 0) {\r\n            return { result: true, code: scans[0] };\r\n        }\r\n        else {\r\n            return { result: false };\r\n        }\r\n    }\r\n    async readInternal(reads = 1) {\r\n        const fInput = document.createElement('input');\r\n        fInput.type = 'file';\r\n        fInput.accept = 'image/*';\r\n        if (reads > 1) {\r\n            fInput.multiple = true;\r\n        }\r\n        fInput.style.display = 'none';\r\n        document.body.appendChild(fInput);\r\n        const promise = new Promise((resolve) => {\r\n            fInput.addEventListener('change', async () => {\r\n                try {\r\n                    if (fInput.files && fInput.files.length > 0) {\r\n                        const scans = [];\r\n                        const min = Math.min(fInput.files.length, reads);\r\n                        for (let i = 0; i < min; i++) {\r\n                            const img = fInput.files[i];\r\n                            const imgData = await this.blobToImageData(img);\r\n                            const code = jsQR(imgData.data, imgData.width, imgData.height);\r\n                            //console.log(code);\r\n                            if (code && code.data) {\r\n                                scans.push(code.data);\r\n                            }\r\n                            else {\r\n                                console.error('jsQR return null', code);\r\n                            }\r\n                        }\r\n                        resolve(scans);\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.error(error);\r\n                }\r\n                document.body.removeChild(fInput);\r\n            });\r\n        });\r\n        fInput.click();\r\n        return promise;\r\n    }\r\n    async blobToImageData(blob, maxWidth = 1500, maxHeight = 1500) {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.readAsDataURL(blob);\r\n            reader.onloadend = () => {\r\n                const image = new Image();\r\n                image.src = reader.result;\r\n                image.onload = () => {\r\n                    const scale = Math.min(maxWidth / image.width, maxHeight / image.height, 1);\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = image.width * scale;\r\n                    canvas.height = image.height * scale;\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n                    // Libera la memoria de la imagen y del canvas\r\n                    canvas.width = 0;\r\n                    canvas.height = 0;\r\n                    resolve(imageData);\r\n                };\r\n                image.onerror = (e) => reject(new Error(\"Error al cargar la imagen.\" + e));\r\n            };\r\n            reader.onerror = (e) => reject(new Error(\"Error al leer el blob.\" + e));\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}